//
//  CTranslation.swift
//  Melia
//
//  Created by RaphaÃ«l Calabro on 30/04/2022.
//

import Foundation
import MeliceFramework

/// Generate header and code files from a TokenTree.
struct PlaydateCodeGenerator {
    var spriteName: String
    var scriptName: String
    var pascalCasedScriptName: String
    var spriteType: MELSpriteType
    var tree: TokenTree
    var symbolTable: SymbolTable

    var headerFile: String {
        let today = Date().formatted(.dateTime.day(.twoDigits).month(.twoDigits).year(.defaultDigits))

        return """
            //
            //  \(scriptName).h
            //
            //  Generated by Melia on \(today).
            //

            #ifndef \(scriptName)_h
            #define \(scriptName)_h

            #include "common.h"
            #include "../lib/melice.h"

            LCDSprite * _Nonnull \(pascalCasedScriptName)Constructor(MELSpriteDefinition * _Nonnull definition, MELSpriteInstance * _Nonnull instance, SpriteLoader * _Nonnull spriteLoader);

            MELSprite * _Nullable \(pascalCasedScriptName)Loader(MELSpriteDefinition * _Nonnull definition, LCDSprite * _Nonnull sprite, SpriteLoader * _Nonnull spriteLoader, MELInputStream * _Nonnull inputStream);

            #endif /* \(scriptName)_h */


            """
    }

    var codeFile: String {
        var code =  cFileStart

        if symbolTable.states.count > 1 {
            code += stateEnumDeclaration
        }
        code += structDeclaration
        code += stateFunctionsDeclaration
        code += goToStateFunction
        code += saveFunction
        code += classDeclaration
        code += loadFunction
        code += constructorFunction
        code += drawFunction

        for state in symbolTable.states {
            let visitor = PlaydateCodeVisitor(state: state, scriptName: scriptName, spriteName: spriteName, symbolTable: symbolTable)
            code += state.accept(visitor: visitor).joined()
        }
        return code
    }

    private var cFileStart: String {
        let today = Date().formatted(.dateTime.day(.twoDigits).month(.twoDigits).year(.defaultDigits))

        return """
        //
        //  \(scriptName).c
        //
        //  Generated by Melia on \(today).
        //

        #include "\(scriptName).h"

        #include "camera.h"
        #include "../gen/spritenames.h"
        #include "../gen/sprite\(spriteName).h"

        extern CameraMotion camera;


        """
    }

    private var stateEnumDeclaration: String {
        var code = "enum \(scriptName)_state {\n"
        for state in symbolTable.states {
            code += "    \(state.name),\n"
        }
        code += "};\n\n"
        return code
    }

    private var structDeclaration: String {
        var code = """
            struct \(scriptName) {
                MELSprite super;


            """

        if symbolTable.states.count > 1 {
            code += "    enum \(scriptName)_state state;\n"
        }
        code += "    uint8_t statePart;\n"
        let variables = symbolTable.variables.keys
            // Ignore global variables.
            .filter { !["self", "delta", "map", "state"].contains($0) }
            .sorted()
        for variable in variables {
            let kind = symbolTable.variables[variable]!
            code += "    \(kind.cType) \(variable);\n"
        }

        code += "};\n\n"
        return code
    }

    private var stateFunctionsDeclaration: String {
        var code = ""
        for state in symbolTable.states {
            for part in 0 ..< state.partCount {
                code += "static void \(state.name)StatePart\(part)(LCDSprite * _Nonnull sprite);\n"
            }
            code += "\n"
        }
        return code
    }

    private var saveFunction: String {
        var code = ""
        if symbolTable.states.count > 1 {
            code += "    MELOutputStreamWriteByte(outputStream, self->state);\n"
        }
        code += "    MELOutputStreamWriteByte(outputStream, self->statePart);\n"
        let variables = symbolTable.variables.keys
            // Ignore global variables.
            .filter { !["self", "delta", "map", "state"].contains($0) }
            .sorted()
        for variable in variables {
            let kind = symbolTable.variables[variable]
            switch (kind) {
            case .direction, .boolean:
                code += "    MELOutputStreamWriteByte(outputStream, self->\(variable));\n"
            case .integer:
                code += "    MELOutputStreamWriteInt(outputStream, self->\(variable));\n"
            case .decimal:
                code += "    MELOutputStreamWriteFloat(outputStream, self->\(variable));\n"
            case .point:
                code += "    MELOutputStreamWritePoint(outputStream, self->\(variable));\n"
            default:
                break
            }
        }
        return """
            static void save(MELSprite * _Nonnull sprite, MELOutputStream * _Nonnull outputStream) {
                struct \(scriptName) *self = (struct \(scriptName) *)sprite;
            \(code)}


            """
    }

    private var loadFunction: String {
        var code = ""
        if symbolTable.states.count > 1 {
            code += "    const enum \(scriptName)_state state = MELInputStreamReadByte(inputStream);\n"
        }
        code += "    const uint8_t statePart = MELInputStreamReadByte(inputStream);\n"
        let variables = symbolTable.variables.keys
            // Ignore global variables.
            .filter { !["self", "delta", "map", "state"].contains($0) }
            .sorted()
        for variable in variables {
            let kind = symbolTable.variables[variable]!
            switch (kind) {
            case .direction, .boolean:
                code += "    const \(kind.cType) \(variable) = MELInputStreamReadByte(inputStream);\n"
            case .integer:
                code += "    const \(kind.cType) \(variable) = MELInputStreamReadInt(inputStream);\n"
            case .decimal:
                code += "    const \(kind.cType) \(variable) = MELInputStreamReadFloat(inputStream);\n"
            case .point:
                code += "    const \(kind.cType) \(variable) = MELInputStreamReadPoint(inputStream);\n"
            default:
                break
            }
        }
        code += """
                *self = (struct \(scriptName)) {
                    .super = {
                        .class = &\(pascalCasedScriptName)Class
                    },

            """
        if symbolTable.states.count > 1 {
            code += "        .state = state,\n"
        }
        code += "        .statePart = statePart,\n"

        for variable in variables {
            let kind = symbolTable.variables[variable]!
            switch (kind) {
            case .direction, .boolean, .integer, .decimal, .point:
                code += "        .\(variable) = \(variable),\n"
            default:
                break
            }
        }
        code += "    };"

        return """
            MELSprite * _Nullable \(pascalCasedScriptName)Loader(MELSpriteDefinition * _Nonnull definition, LCDSprite * _Nonnull sprite, SpriteLoader * _Nonnull spriteLoader, MELInputStream * _Nonnull inputStream) {
                struct \(scriptName) *self = playdate->system->realloc(NULL, sizeof(struct \(scriptName)));
            \(code)
                goToCurrentState(self, sprite);
                return &self->super;
            }


            """
    }

    private var classDeclaration: String {
        return """
            const MELSpriteClass \(pascalCasedScriptName)Class = (MELSpriteClass) {
                .destroy = MELSpriteDealloc,
                .save = save
            };


            """
    }

    private var constructorFunction: String {
        let defaultState = symbolTable.states.isEmpty ? "default" : symbolTable.states[0].name
        return """
            LCDSprite * _Nonnull \(pascalCasedScriptName)Constructor(MELSpriteDefinition * _Nonnull definition, MELSpriteInstance * _Nonnull instance, SpriteLoader * _Nonnull spriteLoader) {
                struct \(scriptName) *self = playdate->system->realloc(NULL, sizeof(struct \(scriptName)));
                LCDSprite *sprite = MELSpriteInit(&self->super, definition, instance, &spriteLoader->sprites);
                self->super.class = &\(pascalCasedScriptName)Class;
                playdate->sprite->setUpdateFunction(sprite, &\(defaultState)StatePart0);
                return sprite;
            }


            """
    }

    private var drawFunction: String {
        if spriteType == MELSpriteTypePlatform {
            return """
                static void draw(struct \(scriptName) * _Nonnull self, LCDSprite * _Nonnull sprite) {
                    self->super.animation->class->update(self->super.animation, DELTA);

                    const MELRectangle frame = self->super.frame;
                    playdate->sprite->moveTo(sprite, frame.origin.x - camera.frame.origin.x, frame.origin.y - camera.frame.origin.y);
                    playdate->sprite->setImage(sprite, playdate->graphics->getTableBitmap(self->super.definition.palette, self->super.animation->frame.atlasIndex), MELDirectionFlip[self->super.direction]);

                    LCDSprite *landedSprite = self->super.landedSprite;
                    if (landedSprite) {
                        MELSprite *landedSpriteSelf = playdate->sprite->getUserdata(landedSprite);
                        MELRectangle landedSpriteFrame = landedSpriteSelf->frame;
                        landedSpriteFrame.origin.x += frame.origin.x - self->super.oldX;
                        // TODO: Utiliser locationForSpriteOnPlatform
                        landedSpriteFrame.origin.y = frame.origin.y - frame.size.height / 2 - landedSpriteFrame.size.height / 2;
                        landedSpriteSelf->frame = landedSpriteFrame;

                        playdate->sprite->moveTo(landedSprite, landedSpriteFrame.origin.x - camera.frame.origin.x, landedSpriteFrame.origin.y - camera.frame.origin.y);
                    }
                    self->super.oldX = frame.origin.x;
                }


                """
        } else {
            return """
                static void draw(struct \(scriptName) * _Nonnull self, LCDSprite * _Nonnull sprite) {
                    self->super.animation->class->update(self->super.animation, DELTA);

                    const MELPoint origin = self->super.frame.origin;
                    playdate->sprite->moveTo(sprite, origin.x - camera.frame.origin.x, origin.y - camera.frame.origin.y);
                    playdate->sprite->setImage(sprite, playdate->graphics->getTableBitmap(self->super.definition.palette, self->super.animation->frame.atlasIndex), MELDirectionFlip[self->super.direction]);
                }


                """
        }
    }

    private func parts(for state: StateNode, indent: String = "    ") -> String {
        if state.partCount == 1 {
            return "\(indent)playdate->sprite->setUpdateFunction(sprite, \(state.name)StatePart0);\n"
        }
        var code = "\(indent)switch (self->statePart) {\n"
        for statePart in 1 ..< state.partCount {
            code += """
                \(indent)    case \(statePart):
                \(indent)        playdate->sprite->setUpdateFunction(sprite, \(state.name)StatePart\(statePart));
                \(indent)        break;

                """
        }
        code += """
            \(indent)    default:
            \(indent)        playdate->sprite->setUpdateFunction(sprite, \(state.name)StatePart0);
            \(indent)        break;
            \(indent)}

            """
        return code
    }

    private var goToStateFunction: String {
        if symbolTable.states.isEmpty {
            return ""
        }
        var code = """
            static void goToCurrentState(struct \(scriptName) * _Nonnull self, LCDSprite * _Nonnull sprite) {

            """
        if symbolTable.states.count > 1 {
            code += """
                    switch (self->state) {

                """

            for state in symbolTable.states[1...] {
                code += """
                            case \(state.name):
                    \(parts(for: state, indent: "            "))            break;

                    """
            }

            code += """
                        default:
                \(parts(for: symbolTable.states[0], indent: "            "))            break;
                    }

                """
        } else {
            code += parts(for: symbolTable.states[0])
        }
        code += "}\n\n"
        return code
    }

    init(tree: TokenTree, for definition: MELSpriteDefinition? = nil) {
        let def = definition ?? MELSpriteDefinition(name: nil, type: MELSpriteTypeDecor, palette: nil, animations: .empty, motionName: nil, loadScript: nil)
        let sprite = MELSpriteAllocStandalone(def)

        let reducedTree = definition != nil ? tree.reduceByInliningValues(from: sprite) : tree

        let spriteName = def.nameAsString.lowercased().replacingOccurrences(of: " ", with: "")
        var scriptName = spriteName
        if let motionName = def.motionName,
           let motionName = String(utf8String: motionName) {
            scriptName = motionName
        }

        self.spriteName = spriteName
        self.scriptName = PlaydateCodeGenerator.removeSpecialCharacters(from: scriptName)
        self.pascalCasedScriptName = PlaydateCodeGenerator.toPascalCase(scriptName)
        self.spriteType = def.type
        self.tree = reducedTree
        self.symbolTable = reducedTree.symbolTable
    }

    private static func removeSpecialCharacters(from string: String) -> String {
        var characters = [Character](string)
        for index in 0 ..< characters.count {
            if characters[index] < "a" || characters[index] > "z" {
                characters[index] = "_"
            }
        }
        return String(characters)
    }

    private static func toPascalCase(_ string: String) -> String {
        var letters = [Character]()
        letters.reserveCapacity(string.count)

        var toUppercase: Bool? = true
        for letter in string {
            if !letter.isLetter && !letter.isNumber {
                toUppercase = true
            } else if toUppercase == true || (toUppercase == nil && letter.isUppercase) {
                toUppercase = false
                letters.append(contentsOf: letter.uppercased())
            } else {
                toUppercase = nil
                letters.append(letter)
            }
        }
        return String(letters);
    }
}

fileprivate extension ValueKind {
    var cType: String {
        switch self {
        case .integer:
            return "int32_t"
        case .decimal:
            return "float"
        case .point:
            return "MELPoint"
        case .boolean:
            return "boolean"
        case .string:
            return "char * _Nullable"
        case .direction:
            return "MELDirection"
        case .sprite:
            return "LCDSprite * _Nullable"
        case .animationName:
            return "AnimationName"
        case .animation:
            return "MELAnimationRef"
        case .animations:
            return "MELAnimationList"
        case .map:
            return "MELMap"
        case .state:
            return "enum xxx_state"
        case .null:
            return "void"
        }
    }
}

fileprivate extension StateNode {
    var partCount: Int {
        return children.filter { $0 is GroupNode }.count + 1
    }
}
