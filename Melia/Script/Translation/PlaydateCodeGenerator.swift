//
//  CTranslation.swift
//  Melia
//
//  Created by Raphaël Calabro on 30/04/2022.
//

import Foundation
import MeliceFramework

/// Generate header and code files from a TokenTree.
struct PlaydateCodeGenerator {
    var spriteName: String
    var scriptName: String
    var tree: TokenTree
    var symbolTable: SymbolTable

    var headerFile: String {
        let today = Date().formatted(.dateTime.day(.twoDigits).month(.twoDigits).year(.defaultDigits))

        return """
            //
            //  \(scriptName).h
            //
            //  Generated by Melia on \(today).
            //

            #ifndef \(scriptName)_h
            #define \(scriptName)_h

            #include "common.h"
            #include "../lib/melice.h"

            void \(scriptName)_update(LCDSprite * _Nonnull sprite);

            #endif /* \(scriptName)_h */


            """
    }

    var codeFile: String {
        var code =  cFileStart

        if symbolTable.states.count > 1 {
            code += stateEnumDeclaration
        }
        code += structDeclaration
        code += stateFunctionsDeclaration
        code += updateFunction
        code += drawFunction

        if symbolTable.states.count > 1 {
            code += goToStateFunction
        }
        for state in symbolTable.states {
            let visitor = PlaydateCodeVisitor(state: state, scriptName: scriptName, spriteName: spriteName, symbolTable: symbolTable)
            code += state.accept(visitor: visitor).joined()
        }
        return code
    }

    private var cFileStart: String {
        let today = Date().formatted(.dateTime.day(.twoDigits).month(.twoDigits).year(.defaultDigits))

        return """
        //
        //  \(scriptName).c
        //
        //  Generated by Melia on \(today).
        //

        #include "\(scriptName).h"

        #include "setanimation.h"
        #include "camera.h"
        #include "../gen/sprite\(spriteName).h"
        #include "../lib/meliasprite.h"

        extern CameraMotion camera;


        """
    }

    private var stateEnumDeclaration: String {
        var code = "enum \(scriptName)_state {\n"
        for state in symbolTable.states {
            code += "    \(state.name),\n"
        }
        code += "};\n\n"
        return code
    }

    private var structDeclaration: String {
        var code = """
            struct \(scriptName) {
                MIASprite super;


            """

        if symbolTable.states.count > 1 {
            code += "    enum \(scriptName)_state state;\n"
        }
        for (variable, kind) in symbolTable.variables {
            // Ignore global variables.
            if ["self", "delta", "map", "state"].contains(variable) {
                continue
            }
            code += "    \(kind.cType) \(variable);\n"
        }

        code += "};\n\n"
        return code
    }

    private var stateFunctionsDeclaration: String {
        var code = ""
        for state in symbolTable.states {
            for part in 0 ..< state.partCount {
                code += "static void \(state.name)StatePart\(part)(LCDSprite * _Nonnull sprite);\n"
            }
            code += "\n"
        }
        return code
    }

    private var updateFunction: String {
        // TODO: Gérer le nommage en PascalCase
        let pascalCasedSpriteName = spriteName.capitalized.replacingOccurrences(of: " ", with: "")
        let defaultState = symbolTable.states.isEmpty ? "default" : symbolTable.states[0].name
        return """
            void \(scriptName)_update(LCDSprite * _Nonnull sprite) {
                struct \(scriptName) *self = playdate->system->realloc(NULL, sizeof(struct \(scriptName)));
                memset(self, 0, sizeof(struct \(scriptName)));
                if (sprite\(pascalCasedSpriteName).palette == NULL) {
                    loadSprite\(pascalCasedSpriteName)Palette();
                }
                self->super.definition = sprite\(pascalCasedSpriteName);
                playdate->sprite->getPosition(sprite, &self->super.frame.origin.x, &self->super.frame.origin.y);

                playdate->sprite->setUserdata(sprite, self);
                playdate->sprite->setUpdateFunction(sprite, &\(defaultState)StatePart0);
                \(defaultState)StatePart0(sprite);
            }


            """
    }

    private var drawFunction: String {
        return """
            static void draw(struct \(scriptName) * _Nonnull self, LCDSprite * _Nonnull sprite) {
                self->super.animation->class->update(self->super.animation, DELTA);
                MELPoint origin = self->super.frame.origin;
                playdate->sprite->moveTo(sprite, origin.x - camera.frame.origin.x, origin.y - camera.frame.origin.y);
                playdate->sprite->setImage(sprite, playdate->graphics->getTableBitmap(self->super.definition.palette, self->super.animation->bitmapIndex), MELDirectionFlip[self->super.direction]);
            }


            """
    }

    private var goToStateFunction: String {
        var code = """
            static void goToCurrentState(LCDSprite * _Nonnull sprite) {
                struct \(scriptName) *self = (struct \(scriptName) *) playdate->sprite->getUserdata(sprite);
                switch (self->super.state) {

            """

        for state in symbolTable.states[1...] {
            code += """
                    case \(state.name):
                            playdate->sprite->setUpdateFunction(sprite, &\(state.name)StatePart0);
                        break;

                """
        }

        code += """
                default:
                        playdate->sprite->setUpdateFunction(sprite, &\(symbolTable.states[0].name)StatePart0);
                    break;
                }
            }


            """
        return code
    }

    init(tree: TokenTree, for definition: MELSpriteDefinition) {
        let sprite = MELSpriteAllocStandalone(definition)
        let reducedTree = tree.reduceByInliningValues(from: sprite)

        let spriteName = definition.nameAsString.lowercased().replacingOccurrences(of: " ", with: "")
        var scriptName = spriteName
        if let motionName = definition.motionName,
           let motionName = String(utf8String: motionName) {
            scriptName = motionName
        }

        self.spriteName = spriteName
        self.scriptName = PlaydateCodeGenerator.removeSpecialCharacters(from: scriptName)
        self.tree = reducedTree
        self.symbolTable = reducedTree.symbolTable
    }

    private static func removeSpecialCharacters(from string: String) -> String {
        var characters = [Character](string)
        for index in 0 ..< characters.count {
            if characters[index] < "a" || characters[index] > "z" {
                characters[index] = "_"
            }
        }
        return String(characters)
    }
}

fileprivate extension ValueKind {
    var cType: String {
        switch self {
        case .integer:
            return "int32_t"
        case .decimal:
            return "float"
        case .point:
            return "MELPoint"
        case .boolean:
            return "boolean"
        case .string:
            return "char * _Nullable"
        case .direction:
            return "MELDirection"
        case .sprite:
            return "LCDSprite * _Nullable"
        case .animationName:
            return "AnimationName"
        case .animation:
            return "MELAnimationRef"
        case .animations:
            return "MELAnimationList"
        case .map:
            return "MELMap"
        case .state:
            return "enum xxx_state"
        case .null:
            return "void"
        }
    }
}

fileprivate extension StateNode {
    var partCount: Int {
        var count = 1
        var lastWasAGroup = false
        for child in children {
            if child is GroupNode {
                count += 1
                lastWasAGroup = true
            } else if lastWasAGroup {
                count += 1
                lastWasAGroup = false
            }
        }
        return count
    }
}
