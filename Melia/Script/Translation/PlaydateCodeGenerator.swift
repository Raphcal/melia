//
//  CTranslation.swift
//  Melia
//
//  Created by Raphaël Calabro on 30/04/2022.
//

import Foundation
import MeliceFramework

/// Generate header and code files from a TokenTree.
struct PlaydateCodeGenerator {
    var spriteName: String
    var scriptName: String
    var pascalCasedScriptName: String
    var spriteType: MELSpriteType
    var tree: TokenTree
    var symbolTable: SymbolTable

    var headerFile: String {
        let today = Date().formatted(.dateTime.day(.twoDigits).month(.twoDigits).year(.defaultDigits))

        return """
            //
            //  \(scriptName).h
            //
            //  Generated by Melia on \(today).
            //

            #ifndef \(scriptName)_h
            #define \(scriptName)_h

            #include "common.h"
            #include "../lib/melice.h"

            LCDSprite * _Nonnull \(pascalCasedScriptName)Constructor(MELConstSpriteDefinition definition, MELSpriteInstance * _Nonnull instance, SpriteLoader * _Nonnull spriteLoader);
            MELSprite * _Nullable \(pascalCasedScriptName)Loader(MELConstSpriteDefinition * _Nonnull definition, MELInputStream * _Nonnull inputStream);

            #endif /* \(scriptName)_h */


            """
    }

    var codeFile: String {
        var code =  cFileStart

        if symbolTable.states.count > 1 {
            code += stateEnumDeclaration
        }
        code += structDeclaration
        code += stateFunctionsDeclaration
        code += saveFunction
        code += loadFunction
        code += classDeclaration
        code += constructorFunction
        code += drawFunction

        if symbolTable.states.count > 1 {
            code += goToStateFunction
        }
        for state in symbolTable.states {
            let visitor = PlaydateCodeVisitor(state: state, scriptName: scriptName, spriteName: spriteName, symbolTable: symbolTable)
            code += state.accept(visitor: visitor).joined()
        }
        return code
    }

    private var cFileStart: String {
        let today = Date().formatted(.dateTime.day(.twoDigits).month(.twoDigits).year(.defaultDigits))

        return """
        //
        //  \(scriptName).c
        //
        //  Generated by Melia on \(today).
        //

        #include "\(scriptName).h"

        #include "camera.h"
        #include "../gen/spritenames.h"
        #include "../gen/sprite\(spriteName).h"

        extern CameraMotion camera;


        """
    }

    private var stateEnumDeclaration: String {
        var code = "enum \(scriptName)_state {\n"
        for state in symbolTable.states {
            code += "    \(state.name),\n"
        }
        code += "};\n\n"
        return code
    }

    private var structDeclaration: String {
        var code = """
            struct \(scriptName) {
                MELSprite super;


            """

        if symbolTable.states.count > 1 {
            code += "    enum \(scriptName)_state state;\n"
        }
        for (variable, kind) in symbolTable.variables {
            // Ignore global variables.
            if ["self", "delta", "map", "state"].contains(variable) {
                continue
            }
            code += "    \(kind.cType) \(variable);\n"
        }

        code += "};\n\n"
        return code
    }

    private var stateFunctionsDeclaration: String {
        var code = ""
        for state in symbolTable.states {
            for part in 0 ..< state.partCount {
                code += "static void \(state.name)StatePart\(part)(LCDSprite * _Nonnull sprite);\n"
            }
            code += "\n"
        }
        return code
    }

    private var hasSomethingToSave: Bool {
        return symbolTable.states.count > 1 || symbolTable.variables.keys.contains { !["self", "delta", "map", "state"].contains($0) }
    }

    private var saveFunction: String {
        var code = ""
        if symbolTable.states.count > 1 {
            code += "    MELOutputStreamWriteByte(outputStream, self->state);\n"
        }
        for (variable, kind) in symbolTable.variables {
            // Ignore global variables.
            if ["self", "delta", "map", "state"].contains(variable) {
                continue
            }
            switch (kind) {
            case .direction, .boolean:
                code += "    MELOutputStreamWriteByte(outputStream, self->\(variable));\n"
            case .integer:
                code += "    MELOutputStreamWriteInt(outputStream, self->\(variable));\n"
            case .decimal:
                code += "    MELOutputStreamWriteFloat(outputStream, self->\(variable));\n"
            case .point:
                code += "    MELOutputStreamWritePoint(outputStream, self->\(variable));\n"
            default:
                break
            }
        }
        if code.isEmpty {
            return ""
        } else {
            return """
                static void save(MELSprite * _Nonnull sprite, MELOutputStream * _Nonnull outputStream) {
                    struct \(scriptName) *self = (struct \(scriptName) *)sprite;
                \(code)}


                """
        }
    }

    private var loadFunction: String {
        var code = ""
        if symbolTable.states.count > 1 {
            code += "    self->state = MELInputStreamReadByte(inputStream);\n"
        }
        for (variable, kind) in symbolTable.variables {
            // Ignore global variables.
            if ["self", "delta", "map", "state"].contains(variable) {
                continue
            }
            switch (kind) {
            case .direction, .boolean:
                code += "    self->\(variable) = MELInputStreamReadByte(inputStream);\n"
            case .integer:
                code += "    self->\(variable) = MELInputStreamReadInt(inputStream);\n"
            case .decimal:
                code += "    self->\(variable) = MELInputStreamReadFloat(inputStream);\n"
            case .point:
                code += "    self->\(variable) = MELInputStreamReadPoint(inputStream);\n"
            default:
                break
            }
        }
        if code.isEmpty {
            return ""
        } else {
            return """
                MELSprite * _Nullable \(pascalCasedScriptName)Loader(MELConstSpriteDefinition * _Nonnull definition, MELInputStream * _Nonnull inputStream) {
                    struct \(scriptName) *self = playdate->system->realloc(NULL, sizeof(struct \(scriptName)));
                \(code)    return &self->super;
                }


                """
        }
    }

    private var classDeclaration: String {
        if hasSomethingToSave {
            return """
                const MELSpriteClass \(pascalCasedScriptName)Class = (MELSpriteClass) {
                    .destroy = MELSpriteDealloc,
                    .save = save
                };


                """
        } else {
            return ""
        }
    }

    private var constructorFunction: String {
        // TODO: Gérer le nommage en PascalCase
        let defaultState = symbolTable.states.isEmpty ? "default" : symbolTable.states[0].name
        return """
            LCDSprite * _Nonnull \(pascalCasedScriptName)Constructor(MELConstSpriteDefinition definition, MELSpriteInstance * _Nonnull instance, SpriteLoader * _Nonnull spriteLoader) {
                LCDSprite *sprite = playdate->sprite->newSprite();
                playdate->sprite->moveTo(sprite, instance->center.x, instance->center.y);
                playdate->sprite->setZIndex(sprite, instance->zIndex);

                struct \(scriptName) *self = playdate->system->realloc(NULL, sizeof(struct \(scriptName)));
                *self = (struct \(scriptName)) {
                    .super = (MELSprite) {
                        .class = \(hasSomethingToSave ? "&\(pascalCasedScriptName)Class" : "&MELSpriteClassDefault"),
                        .definition = definition,
                        .instance = instance,
                        .frame = (MELRectangle) {
                            .origin = instance->center,
                            .size = definition.size
                        },
                        .direction = instance->direction,
                        .oldX = instance->center.x,
                        .otherSprites = &spriteLoader->sprites,
                    }
                };
                MELSpriteSetAnimation(&self->super, AnimationNameStand);

                if (!MELRectangleEquals(self->super.animation->frame.hitbox, MELRectangleZero)) {
                    self->super.hitbox = MELSpriteHitboxAlloc(&self->super);
                } else {
                    self->super.hitbox = MELSimpleSpriteHitboxAlloc(&self->super);
                }

                playdate->sprite->setUserdata(sprite, self);
                playdate->sprite->setUpdateFunction(sprite, &\(defaultState)StatePart0);
                playdate->sprite->addSprite(sprite);

                instance->sprite = sprite;
                return sprite;
            }


            """
    }

    private var drawFunction: String {
        if spriteType == MELSpriteTypePlatform {
            return """
                static void draw(struct \(scriptName) * _Nonnull self, LCDSprite * _Nonnull sprite) {
                    self->super.animation->class->update(self->super.animation, DELTA);

                    const MELRectangle frame = self->super.frame;
                    playdate->sprite->moveTo(sprite, frame.origin.x - camera.frame.origin.x, frame.origin.y - camera.frame.origin.y);
                    playdate->sprite->setImage(sprite, playdate->graphics->getTableBitmap(self->super.definition.palette, self->super.animation->frame.atlasIndex), MELDirectionFlip[self->super.direction]);

                    LCDSprite *landedSprite = self->super.landedSprite;
                    if (landedSprite) {
                        MELSprite *landedSpriteSelf = playdate->sprite->getUserdata(landedSprite);
                        MELRectangle landedSpriteFrame = landedSpriteSelf->frame;
                        landedSpriteFrame.origin.x += frame.origin.x - self->super.oldX;
                        // TODO: Utiliser locationForSpriteOnPlatform
                        landedSpriteFrame.origin.y = frame.origin.y - frame.size.height / 2 - landedSpriteFrame.size.height / 2;
                        landedSpriteSelf->frame = landedSpriteFrame;

                        playdate->sprite->moveTo(landedSprite, landedSpriteFrame.origin.x - camera.frame.origin.x, landedSpriteFrame.origin.y - camera.frame.origin.y);
                    }
                    self->super.oldX = frame.origin.x;
                }


                """
        } else {
            return """
                static void draw(struct \(scriptName) * _Nonnull self, LCDSprite * _Nonnull sprite) {
                    self->super.animation->class->update(self->super.animation, DELTA);

                    const MELPoint origin = self->super.frame.origin;
                    playdate->sprite->moveTo(sprite, origin.x - camera.frame.origin.x, origin.y - camera.frame.origin.y);
                    playdate->sprite->setImage(sprite, playdate->graphics->getTableBitmap(self->super.definition.palette, self->super.animation->frame.atlasIndex), MELDirectionFlip[self->super.direction]);
                }


                """
        }
    }

    private var goToStateFunction: String {
        var code = """
            static void goToCurrentState(LCDSprite * _Nonnull sprite) {
                struct \(scriptName) *self = playdate->sprite->getUserdata(sprite);
                switch (self->super.state) {

            """

        for state in symbolTable.states[1...] {
            code += """
                    case \(state.name):
                            playdate->sprite->setUpdateFunction(sprite, &\(state.name)StatePart0);
                        break;

                """
        }

        code += """
                default:
                        playdate->sprite->setUpdateFunction(sprite, &\(symbolTable.states[0].name)StatePart0);
                    break;
                }
            }


            """
        return code
    }

    init(tree: TokenTree, for definition: MELSpriteDefinition? = nil) {
        let def = definition ?? MELSpriteDefinition(name: nil, type: MELSpriteTypeDecor, palette: nil, animations: .empty, motionName: nil, loadScript: nil)
        let sprite = MELSpriteAllocStandalone(def)

        let reducedTree = definition != nil ? tree.reduceByInliningValues(from: sprite) : tree

        let spriteName = def.nameAsString.lowercased().replacingOccurrences(of: " ", with: "")
        var scriptName = spriteName
        if let motionName = def.motionName,
           let motionName = String(utf8String: motionName) {
            scriptName = motionName
        }

        self.spriteName = spriteName
        self.scriptName = PlaydateCodeGenerator.removeSpecialCharacters(from: scriptName)
        self.pascalCasedScriptName = PlaydateCodeGenerator.toPascalCase(scriptName)
        self.spriteType = def.type
        self.tree = reducedTree
        self.symbolTable = reducedTree.symbolTable
    }

    private static func removeSpecialCharacters(from string: String) -> String {
        var characters = [Character](string)
        for index in 0 ..< characters.count {
            if characters[index] < "a" || characters[index] > "z" {
                characters[index] = "_"
            }
        }
        return String(characters)
    }

    private static func toPascalCase(_ string: String) -> String {
        var letters = [Character]()
        letters.reserveCapacity(string.count)

        var toUppercase: Bool? = true
        for letter in string {
            if !letter.isLetter && !letter.isNumber {
                toUppercase = true
            } else if toUppercase == true || (toUppercase == nil && letter.isUppercase) {
                toUppercase = false
                letters.append(contentsOf: letter.uppercased())
            } else {
                toUppercase = nil
                letters.append(letter)
            }
        }
        return String(letters);
    }
}

fileprivate extension ValueKind {
    var cType: String {
        switch self {
        case .integer:
            return "int32_t"
        case .decimal:
            return "float"
        case .point:
            return "MELPoint"
        case .boolean:
            return "boolean"
        case .string:
            return "char * _Nullable"
        case .direction:
            return "MELDirection"
        case .sprite:
            return "LCDSprite * _Nullable"
        case .animationName:
            return "AnimationName"
        case .animation:
            return "MELAnimationRef"
        case .animations:
            return "MELAnimationList"
        case .map:
            return "MELMap"
        case .state:
            return "enum xxx_state"
        case .null:
            return "void"
        }
    }
}

fileprivate extension StateNode {
    var partCount: Int {
        var count = 1
        var lastWasAGroup = false
        for child in children {
            if child is GroupNode {
                count += 1
                lastWasAGroup = true
            } else if lastWasAGroup {
                count += 1
                lastWasAGroup = false
            }
        }
        return count
    }
}
