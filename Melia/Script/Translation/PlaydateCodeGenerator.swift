//
//  CTranslation.swift
//  Melia
//
//  Created by Raphaël Calabro on 30/04/2022.
//

import Foundation
import MeliceFramework

/// Generate header and code files from a TokenTree.
struct PlaydateCodeGenerator {
    var spriteName: String
    var scriptName: String
    var spriteType: MELSpriteType
    var tree: TokenTree
    var symbolTable: SymbolTable

    var headerFile: String {
        let today = Date().formatted(.dateTime.day(.twoDigits).month(.twoDigits).year(.defaultDigits))

        return """
            //
            //  \(scriptName).h
            //
            //  Generated by Melia on \(today).
            //

            #ifndef \(scriptName)_h
            #define \(scriptName)_h

            #include "common.h"
            #include "../lib/melice.h"

            LCDSprite * _Nonnull \(scriptName)_constructor(MELConstSpriteDefinition definition, MELSpriteInstance * _Nonnull instance);

            #endif /* \(scriptName)_h */


            """
    }

    var codeFile: String {
        var code =  cFileStart

        if symbolTable.states.count > 1 {
            code += stateEnumDeclaration
        }
        code += structDeclaration
        code += stateFunctionsDeclaration
        code += updateFunction
        code += drawFunction

        if symbolTable.states.count > 1 {
            code += goToStateFunction
        }
        for state in symbolTable.states {
            let visitor = PlaydateCodeVisitor(state: state, scriptName: scriptName, spriteName: spriteName, symbolTable: symbolTable)
            code += state.accept(visitor: visitor).joined()
        }
        return code
    }

    private var cFileStart: String {
        let today = Date().formatted(.dateTime.day(.twoDigits).month(.twoDigits).year(.defaultDigits))

        return """
        //
        //  \(scriptName).c
        //
        //  Generated by Melia on \(today).
        //

        #include "\(scriptName).h"

        #include "setanimation.h"
        #include "camera.h"
        #include "../gen/spritenames.h"
        #include "../gen/sprite\(spriteName).h"

        extern CameraMotion camera;


        """
    }

    private var stateEnumDeclaration: String {
        var code = "enum \(scriptName)_state {\n"
        for state in symbolTable.states {
            code += "    \(state.name),\n"
        }
        code += "};\n\n"
        return code
    }

    private var structDeclaration: String {
        var code = """
            struct \(scriptName) {
                MELSprite super;


            """

        if symbolTable.states.count > 1 {
            code += "    enum \(scriptName)_state state;\n"
        }
        for (variable, kind) in symbolTable.variables {
            // Ignore global variables.
            if ["self", "delta", "map", "state"].contains(variable) {
                continue
            }
            code += "    \(kind.cType) \(variable);\n"
        }

        code += "};\n\n"
        return code
    }

    private var stateFunctionsDeclaration: String {
        var code = ""
        for state in symbolTable.states {
            for part in 0 ..< state.partCount {
                code += "static void \(state.name)StatePart\(part)(LCDSprite * _Nonnull sprite);\n"
            }
            code += "\n"
        }
        return code
    }

    private var updateFunction: String {
        // TODO: Gérer le nommage en PascalCase
        let defaultState = symbolTable.states.isEmpty ? "default" : symbolTable.states[0].name
        return """
            LCDSprite * _Nonnull \(scriptName)_constructor(MELConstSpriteDefinition definition, MELSpriteInstance * _Nonnull instance) {
                LCDSprite *sprite = playdate->sprite->newSprite();
                playdate->sprite->moveTo(sprite, instance->center.x, instance->center.y);
                // TODO: Voir comment gérer le z-index

                struct \(scriptName) *self = playdate->system->realloc(NULL, sizeof(struct \(scriptName)));
                *self = (struct \(scriptName)) {
                    .super = (MELSprite) {
                        .class = &MELSpriteClassDefault,
                        .definition = definition,
                        .frame = (MELRectangle) {
                            .origin = instance->center,
                            .size = definition.size
                        },
                        .oldX = instance->center.x
                    }
                };
                AnimationNameSetAnimation(AnimationNameStand, instance->direction, definition, &self->super.animationName, &self->super.animation);

                if (!MELRectangleEquals(self->super.animation->frame.hitbox, MELRectangleZero)) {
                    self->super.hitbox = MELSpriteHitboxAlloc(&self->super);
                } else {
                    self->super.hitbox = MELSimpleSpriteHitboxAlloc(&self->super);
                }

                if (!MELRectangleEquals(self->super.animation->frame.hitbox, MELRectangleZero)) {
                    self->super.hitbox = MELSpriteHitboxAlloc(&self->super);
                } else {
                    self->super.hitbox = MELSimpleSpriteHitboxAlloc(&self->super);
                }

                playdate->sprite->setUserdata(sprite, self);
                playdate->sprite->setUpdateFunction(sprite, &\(defaultState)StatePart0);
                playdate->sprite->addSprite(sprite);

                instance->sprite = sprite;
                return sprite;
            }


            """
    }

    private var drawFunction: String {
        if spriteType == MELSpriteTypePlatform {
            return """
                static void draw(struct \(scriptName) * _Nonnull self, LCDSprite * _Nonnull sprite) {
                    self->super.animation->class->update(self->super.animation, DELTA);

                    const MELRectangle frame = self->super.frame;
                    playdate->sprite->moveTo(sprite, frame.origin.x - camera.frame.origin.x, frame.origin.y - camera.frame.origin.y);
                    playdate->sprite->setImage(sprite, playdate->graphics->getTableBitmap(self->super.definition.palette, self->super.animation->frame.atlasIndex), MELDirectionFlip[self->super.direction]);

                    LCDSprite *landedSprite = self->super.landedSprite;
                    if (landedSprite) {
                        MELSprite *landedSpriteSelf = playdate->sprite->getUserdata(landedSprite);
                        MELRectangle landedSpriteFrame = landedSpriteSelf->frame;
                        landedSpriteFrame.origin.x += frame.origin.x - self->super.oldX;
                        // TODO: Utiliser locationForSpriteOnPlatform
                        landedSpriteFrame.origin.y = frame.origin.y - frame.size.height / 2 - landedSpriteFrame.size.height / 2;
                        landedSpriteSelf->frame = landedSpriteFrame;

                        playdate->sprite->moveTo(landedSprite, landedSpriteFrame.origin.x - camera.frame.origin.x, landedSpriteFrame.origin.y - camera.frame.origin.y);
                    }
                    self->super.oldX = frame.origin.x;
                }


                """
        } else {
            return """
                static void draw(struct \(scriptName) * _Nonnull self, LCDSprite * _Nonnull sprite) {
                    self->super.animation->class->update(self->super.animation, DELTA);

                    const MELPoint origin = self->super.frame.origin;
                    playdate->sprite->moveTo(sprite, origin.x - camera.frame.origin.x, origin.y - camera.frame.origin.y);
                    playdate->sprite->setImage(sprite, playdate->graphics->getTableBitmap(self->super.definition.palette, self->super.animation->frame.atlasIndex), MELDirectionFlip[self->super.direction]);
                }


                """
        }
    }

    private var goToStateFunction: String {
        var code = """
            static void goToCurrentState(LCDSprite * _Nonnull sprite) {
                struct \(scriptName) *self = (struct \(scriptName) *) playdate->sprite->getUserdata(sprite);
                switch (self->super.state) {

            """

        for state in symbolTable.states[1...] {
            code += """
                    case \(state.name):
                            playdate->sprite->setUpdateFunction(sprite, &\(state.name)StatePart0);
                        break;

                """
        }

        code += """
                default:
                        playdate->sprite->setUpdateFunction(sprite, &\(symbolTable.states[0].name)StatePart0);
                    break;
                }
            }


            """
        return code
    }

    init(tree: TokenTree, for definition: MELSpriteDefinition? = nil) {
        let def = definition ?? MELSpriteDefinition(name: nil, type: MELSpriteTypeDecor, palette: nil, animations: .empty, motionName: nil, loadScript: nil)
        let sprite = MELSpriteAllocStandalone(def)

        let reducedTree = definition != nil ? tree.reduceByInliningValues(from: sprite) : tree

        let spriteName = def.nameAsString.lowercased().replacingOccurrences(of: " ", with: "")
        var scriptName = spriteName
        if let motionName = def.motionName,
           let motionName = String(utf8String: motionName) {
            scriptName = motionName
        }

        self.spriteName = spriteName
        self.scriptName = PlaydateCodeGenerator.removeSpecialCharacters(from: scriptName)
        self.spriteType = def.type
        self.tree = reducedTree
        self.symbolTable = reducedTree.symbolTable
    }

    private static func removeSpecialCharacters(from string: String) -> String {
        var characters = [Character](string)
        for index in 0 ..< characters.count {
            if characters[index] < "a" || characters[index] > "z" {
                characters[index] = "_"
            }
        }
        return String(characters)
    }
}

fileprivate extension ValueKind {
    var cType: String {
        switch self {
        case .integer:
            return "int32_t"
        case .decimal:
            return "float"
        case .point:
            return "MELPoint"
        case .boolean:
            return "boolean"
        case .string:
            return "char * _Nullable"
        case .direction:
            return "MELDirection"
        case .sprite:
            return "LCDSprite * _Nullable"
        case .animationName:
            return "AnimationName"
        case .animation:
            return "MELAnimationRef"
        case .animations:
            return "MELAnimationList"
        case .map:
            return "MELMap"
        case .state:
            return "enum xxx_state"
        case .null:
            return "void"
        }
    }
}

fileprivate extension StateNode {
    var partCount: Int {
        var count = 1
        var lastWasAGroup = false
        for child in children {
            if child is GroupNode {
                count += 1
                lastWasAGroup = true
            } else if lastWasAGroup {
                count += 1
                lastWasAGroup = false
            }
        }
        return count
    }
}
