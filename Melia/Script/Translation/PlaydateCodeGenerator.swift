//
//  CTranslation.swift
//  Melia
//
//  Created by Raphaël Calabro on 30/04/2022.
//

import Foundation
import MeliceFramework

struct PlaydateCodeGenerator {
    var spriteName: String
    var scriptName: String
    var tree: TokenTree
    var symbolTable: SymbolTable

    var headerFile: String {
        let today = Date().formatted(.dateTime.day(.twoDigits).month(.twoDigits).year(.defaultDigits))

        return """
            //
            //  \(scriptName).h
            //
            //  Generated by Melia on \(today).
            //

            #ifndef \(scriptName)_h
            #define \(scriptName)_h

            #include "common.h"
            #include "../lib/melice.h"

            void \(scriptName)_update(LCDSprite * _Nonnull sprite);

            #endif /* \(scriptName)_h */


            """
    }

    var codeFile: String {
        var code =  cFileStart

        if symbolTable.states.count > 1 {
            code += stateEnumDeclaration
        }
        code += structDeclaration
        code += stateFunctionsDeclaration
        code += updateFunction
        code += drawFunction

        if symbolTable.states.count > 1 {
            code += goToStateFunction
        }
        for state in symbolTable.states {
            code += generate(state: state, symbolTable: symbolTable, scriptName: scriptName)
        }
        return code
    }

    private var cFileStart: String {
        let today = Date().formatted(.dateTime.day(.twoDigits).month(.twoDigits).year(.defaultDigits))

        return """
        //
        //  \(scriptName).c
        //
        //  Generated by Melia on \(today).
        //

        #include "\(scriptName).h"

        #include "../gen/sprite\(spriteName).h"

        extern MELRectangle camera;


        """
    }

    private var stateEnumDeclaration: String {
        var code = "enum \(scriptName)_state {\n"
        for state in symbolTable.states {
            code += "    \(state.name),\n"
        }
        code += "};\n\n"
        return code
    }

    private var structDeclaration: String {
        var code = """
            struct \(scriptName) {
                MELConstSpriteDefinition definition;
                AnimationName animationName;
                MELAnimation * _Nullable animation;
                MELRectangle frame;
                MELDirection direction;


            """

        if symbolTable.states.count > 1 {
            code += "    enum \(scriptName)_state state;\n"
        }
        for (variable, kind) in symbolTable.variables {
            if ["self", "delta", "map"].contains(variable) {
                continue
            }
            code += "    \(kind.cType) \(variable);\n"
        }

        code += "};\n\n"
        return code
    }

    private var stateFunctionsDeclaration: String {
        var code = ""
        for state in symbolTable.states {
            for part in 0 ..< state.partCount {
                code += "static void \(state.name)StatePart\(part)(LCDSprite * _Nonnull sprite);\n"
            }
            code += "\n"
        }
        return code
    }

    private var updateFunction: String {
        // TODO: Gérer le nommage en PascalCase
        let pascalCasedSpriteName = spriteName.capitalized
        let defaultState = symbolTable.states.isEmpty ? "default" : symbolTable.states[0].name
        return """
            void \(scriptName)_update(LCDSprite * _Nonnull sprite) {
                struct \(scriptName) *self = playdate->system->realloc(NULL, sizeof(struct \(scriptName)));
                memset(self, 0, sizeof(struct \(scriptName)));
                if (sprite\(pascalCasedSpriteName).palette == NULL) {
                    loadSprite\(pascalCasedSpriteName)Palette();
                }
                self->definition = sprite\(pascalCasedSpriteName);
                playdate->sprite->getPosition(sprite, &self->origin.x, &self->origin.y);

                playdate->sprite->setUserdata(sprite, self);
                playdate->sprite->setUpdateFunction(sprite, &\(defaultState)StatePart0);
                \(defaultState)StatePart0(sprite);
            }


            """
    }

    private var drawFunction: String {
        return """
            static void draw(struct \(scriptName) * _Nonnull self, LCDSprite * _Nonnull sprite) {
                self->animation->class->update(self->animation, DELTA);
                MELPoint origin = self->frame.origin;
                playdate->sprite->moveTo(sprite, origin.x - camera.origin.x, origin.y - camera.origin.y);
                playdate->sprite->setImage(sprite, playdate->graphics->getTableBitmap(self->definition.palette, self->animation->bitmapIndex), MELDirectionFlip[self->direction]);
            }


            """
    }

    private var goToStateFunction: String {
        var code = """
            static void goToCurrentState(LCDSprite * _Nonnull sprite) {
                struct \(scriptName) *self = (struct \(scriptName) *) playdate->sprite->getUserdata(sprite);
                switch (self->state) {

            """

        for state in symbolTable.states[1...] {
            code += """
                    case \(state.name):
                            playdate->sprite->setUpdateFunction(sprite, &\(state.name)StatePart0);
                        break;

                """
        }

        code += """
                default:
                        playdate->sprite->setUpdateFunction(sprite, &\(symbolTable.states[0].name)StatePart0);
                    break;
                }
            }


            """
        return code
    }

    init(tree: TokenTree, for definition: MELSpriteDefinition) {
        let sprite = MELSpriteAllocStandalone(definition)
        let reducedTree = tree.reduceByInliningValues(from: sprite)

        let spriteName = definition.nameAsString.lowercased()
        var scriptName = spriteName
        if let motionName = definition.motionName,
           let motionName = String(utf8String: motionName) {
            scriptName = motionName
        }

        self.spriteName = spriteName
        self.scriptName = PlaydateCodeGenerator.removeSpecialCharacters(from: scriptName)
        self.tree = reducedTree
        self.symbolTable = reducedTree.symbolTable
    }

    private func generate(state: StateNode, symbolTable: SymbolTable, scriptName: String) -> String {
        var part = 0
        return PlaydateCodeGenerator.generateStart(of: state.name, part: part, scriptName: scriptName)
        + state.children.playdateCode(state: state.name, part: &part, scriptName: scriptName)
        + "}\n\n"
    }

    fileprivate static func generateStart(of state: String, part: Int, scriptName: String) -> String {
        return """
            static void \(state)StatePart\(part)(LCDSprite * _Nonnull sprite) {
                struct \(scriptName) *self = (struct \(scriptName) *) playdate->sprite->getUserdata(sprite);


            """
    }


    private static func removeSpecialCharacters(from string: String) -> String {
        var characters = [Character](string)
        for index in 0 ..< characters.count {
            if characters[index] < "a" || characters[index] > "z" {
                characters[index] = "_"
            }
        }
        return String(characters)
    }
}

fileprivate extension ValueKind {
    var cType: String {
        switch self {
        case .integer:
            return "int32_t"
        case .decimal:
            return "float"
        case .point:
            return "MELPoint"
        case .boolean:
            return "boolean"
        case .string:
            return "char * _Nullable"
        case .direction:
            return "MELDirection"
        case .sprite:
            return "LCDSprite * _Nullable"
        case .animation:
            return "MELAnimationRef"
        case .animations:
            return "MELAnimationList"
        case .map:
            return "MELMap"
        case .null:
            return "void"
        }
    }
}

fileprivate extension StateNode {
    var partCount: Int {
        var count = 1
        var lastWasAGroup = false
        for child in children {
            if child is GroupNode {
                count += 1
                lastWasAGroup = true
            } else if lastWasAGroup {
                count += 1
                lastWasAGroup = false
            }
        }
        return count
    }
}

fileprivate protocol CanGeneratePlaydateCode {
    func playdateCode(state: String, part: inout Int, scriptName: String) -> String
}

fileprivate extension TreeNode {
    func playdateCode(state: String, part: inout Int, scriptName: String) -> String {
        return (self as? CanGeneratePlaydateCode)?.playdateCode(state: state, part: &part, scriptName: scriptName) ?? ""
    }
}

extension Array where Element == TreeNode {
    func playdateCode(state: String, part: inout Int, scriptName: String) -> String {
        return self.map({ $0.playdateCode(state: state, part: &part, scriptName: scriptName) }).joined()
    }
}

extension GroupNode: CanGeneratePlaydateCode {
    func playdateCode(state: String, part: inout Int, scriptName: String) -> String {
        // TODO: Faire un nœud spécialisé pour during ?
        part += 1
        var code = [String]()
        code.reserveCapacity(6)
        code.append("""
                // \(name)
                self->time = 0;
                playdate->sprite->setUpdateFunction(sprite, &\(state)StatePart\(part);

                draw(self, sprite);
            }


            """)
        code.append(PlaydateCodeGenerator.generateStart(of: state, part: part, scriptName: scriptName))

        let duration = arguments.first { $0.name == "duration" }?.value ?? ConstantNode(value: .decimal(0))
        code.append("""
                /// \(name)
                const float duration = \(duration.playdateCode(state: state, part: &part, scriptName: scriptName));
                if (self->time < duration) {
                    self->time = MELFloatMin(self->time + DELTA, 1);


            """)
        code.append(children.playdateCode(state: state, part: &part, scriptName: scriptName))
        part += 1
        code.append("""
                } else {
                    playdate->sprite->setUpdateFunction(sprite, &\(state)StatePart\(part);
                }

                draw(self, sprite);
            }


            """)
        code.append(PlaydateCodeGenerator.generateStart(of: state, part: part, scriptName: scriptName))
        return code.joined()
    }
}

extension InstructionNode: CanGeneratePlaydateCode {
    func playdateCode(state: String, part: inout Int, scriptName: String) -> String {
        return "// \(name)\n"
    }
}
